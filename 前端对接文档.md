# Vue + Axios 前端对接认证API文档

## 服务器配置
- **后端地址**: `http://localhost:8089`
- **认证方式**: Session + Cookie
- **跨域支持**: 已配置CORS

## 1. Axios 配置

### 基础配置
```javascript
// api/index.js
import axios from 'axios'

// 创建axios实例
const api = axios.create({
  baseURL: 'http://localhost:8089/api',
  timeout: 10000,
  withCredentials: true, // 重要：允许携带cookie
  headers: {
    'Content-Type': 'application/json',
  }
})

// 获取CSRF Token的函数
const getCSRFToken = () => {
  const name = 'csrftoken'
  let cookieValue = null
  if (document.cookie && document.cookie !== '') {
    const cookies = document.cookie.split(';')
    for (let i = 0; i < cookies.length; i++) {
      const cookie = cookies[i].trim()
      if (cookie.substring(0, name.length + 1) === (name + '=')) {
        cookieValue = decodeURIComponent(cookie.substring(name.length + 1))
        break
      }
    }
  }
  return cookieValue
}

// 请求拦截器
api.interceptors.request.use(
  config => {
    // 为POST、PUT、PATCH、DELETE请求添加CSRF Token
    if (['post', 'put', 'patch', 'delete'].includes(config.method.toLowerCase())) {
      const csrfToken = getCSRFToken()
      if (csrfToken) {
        config.headers['X-CSRFToken'] = csrfToken
      }
    }
    return config
  },
  error => {
    return Promise.reject(error)
  }
)

// 响应拦截器
api.interceptors.response.use(
  response => {
    const { data } = response
    
    // 统一处理响应
    if (data.code === 0) {
      return data
    } else {
      // 处理业务错误
      throw new Error(data.message || '请求失败')
    }
  },
  error => {
    // 处理HTTP错误
    if (error.response?.status === 401) {
      // 未认证，跳转到登录页
      router.push('/login')
    }
    return Promise.reject(error)
  }
)

export default api
```

## 2. 认证API封装

### 创建认证服务
```javascript
// api/auth.js
import api from './index'

export const authAPI = {
  // 获取CSRF Token（首次访问时调用）
  getCSRFToken() {
    return api.get('/account/login/') // GET请求获取CSRF Token
  },

  // 用户登录
  login(credentials) {
    return api.post('/account/login/', credentials)
  },

  // 获取用户信息
  getUserInfo() {
    return api.get('/account/user-info/')
  },

  // 用户登出
  logout() {
    return api.post('/account/logout/')
  },

  // 获取用户列表（需要权限）
  getUserList() {
    return api.get('/account/users/')
  }
}
```

## 3. Vuex/Pinia 状态管理

### 使用Pinia（推荐）
```javascript
// stores/auth.js
import { defineStore } from 'pinia'
import { authAPI } from '@/api/auth'

export const useAuthStore = defineStore('auth', {
  state: () => ({
    user: null,
    isAuthenticated: false,
    loading: false
  }),

  getters: {
    isAdmin: (state) => state.user?.is_superuser || false,
    username: (state) => state.user?.username || ''
  },

  actions: {
    // 登录
    async login(credentials) {
      this.loading = true
      try {
        // 首先获取CSRF Token
        await authAPI.getCSRFToken()
        
        // 然后进行登录
        const response = await authAPI.login(credentials)
        this.user = response.data.user
        this.isAuthenticated = true
        return response
      } catch (error) {
        this.user = null
        this.isAuthenticated = false
        throw error
      } finally {
        this.loading = false
      }
    },

    // 获取用户信息
    async fetchUserInfo() {
      try {
        const response = await authAPI.getUserInfo()
        this.user = response.data
        this.isAuthenticated = true
        return response
      } catch (error) {
        this.user = null
        this.isAuthenticated = false
        throw error
      }
    },

    // 登出
    async logout() {
      try {
        await authAPI.logout()
      } catch (error) {
        console.error('登出失败:', error)
      } finally {
        this.user = null
        this.isAuthenticated = false
      }
    },

    // 检查认证状态
    async checkAuth() {
      try {
        await this.fetchUserInfo()
      } catch (error) {
        this.user = null
        this.isAuthenticated = false
      }
    }
  }
})
```

### 使用Vuex
```javascript
// store/modules/auth.js
import { authAPI } from '@/api/auth'

const state = {
  user: null,
  isAuthenticated: false,
  loading: false
}

const mutations = {
  SET_USER(state, user) {
    state.user = user
  },
  SET_AUTHENTICATED(state, status) {
    state.isAuthenticated = status
  },
  SET_LOADING(state, status) {
    state.loading = status
  }
}

const actions = {
  async login({ commit }, credentials) {
    commit('SET_LOADING', true)
    try {
      const response = await authAPI.login(credentials)
      commit('SET_USER', response.data.user)
      commit('SET_AUTHENTICATED', true)
      return response
    } catch (error) {
      commit('SET_USER', null)
      commit('SET_AUTHENTICATED', false)
      throw error
    } finally {
      commit('SET_LOADING', false)
    }
  },

  async logout({ commit }) {
    try {
      await authAPI.logout()
    } finally {
      commit('SET_USER', null)
      commit('SET_AUTHENTICATED', false)
    }
  }
}

export default {
  namespaced: true,
  state,
  mutations,
  actions
}
```

## 4. Vue组件示例

### 登录组件
```vue
<!-- views/Login.vue -->
<template>
  <div class="login-container">
    <form @submit.prevent="handleLogin" class="login-form">
      <h2>用户登录</h2>
      
      <div class="form-group">
        <label>用户名:</label>
        <input 
          v-model="form.username" 
          type="text" 
          required 
          placeholder="请输入用户名"
        />
      </div>
      
      <div class="form-group">
        <label>密码:</label>
        <input 
          v-model="form.password" 
          type="password" 
          required 
          placeholder="请输入密码"
        />
      </div>
      
      <button type="submit" :disabled="loading">
        {{ loading ? '登录中...' : '登录' }}
      </button>
      
      <div v-if="error" class="error">{{ error }}</div>
    </form>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import { useRouter } from 'vue-router'
import { useAuthStore } from '@/stores/auth' // Pinia
// import { useStore } from 'vuex' // Vuex

const router = useRouter()
const authStore = useAuthStore() // Pinia
// const store = useStore() // Vuex

const form = ref({
  username: '',
  password: ''
})

const error = ref('')
const loading = ref(false)

const handleLogin = async () => {
  if (!form.value.username || !form.value.password) {
    error.value = '请填写完整信息'
    return
  }

  loading.value = true
  error.value = ''

  try {
    // Pinia
    await authStore.login(form.value)
    
    // Vuex
    // await store.dispatch('auth/login', form.value)
    
    router.push('/dashboard')
  } catch (err) {
    error.value = err.message || '登录失败'
  } finally {
    loading.value = false
  }
}
</script>

<style scoped>
.login-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
}

.login-form {
  width: 400px;
  padding: 2rem;
  border: 1px solid #ddd;
  border-radius: 8px;
}

.form-group {
  margin-bottom: 1rem;
}

.form-group label {
  display: block;
  margin-bottom: 0.5rem;
}

.form-group input {
  width: 100%;
  padding: 0.5rem;
  border: 1px solid #ddd;
  border-radius: 4px;
}

button {
  width: 100%;
  padding: 0.75rem;
  background: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button:disabled {
  background: #ccc;
}

.error {
  color: red;
  margin-top: 1rem;
}
</style>
```

### 用户信息组件
```vue
<!-- components/UserProfile.vue -->
<template>
  <div class="user-profile">
    <div v-if="user">
      <h3>用户信息</h3>
      <p><strong>用户名:</strong> {{ user.username }}</p>
      <p><strong>邮箱:</strong> {{ user.email }}</p>
      <p><strong>管理员:</strong> {{ user.is_superuser ? '是' : '否' }}</p>
      <p><strong>注册时间:</strong> {{ formatDate(user.date_joined) }}</p>
      <p><strong>最后登录:</strong> {{ formatDate(user.last_login) }}</p>
      
      <button @click="handleLogout" class="logout-btn">
        登出
      </button>
    </div>
    
    <div v-else>
      <p>未登录</p>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { useRouter } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

const router = useRouter()
const authStore = useAuthStore()

const user = computed(() => authStore.user)

const formatDate = (dateString) => {
  if (!dateString) return '未知'
  return new Date(dateString).toLocaleString('zh-CN')
}

const handleLogout = async () => {
  try {
    await authStore.logout()
    router.push('/login')
  } catch (error) {
    console.error('登出失败:', error)
  }
}
</script>
```

## 5. 路由守卫

```javascript
// router/index.js
import { createRouter, createWebHistory } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

const routes = [
  {
    path: '/login',
    name: 'Login',
    component: () => import('@/views/Login.vue'),
    meta: { requiresGuest: true }
  },
  {
    path: '/dashboard',
    name: 'Dashboard',
    component: () => import('@/views/Dashboard.vue'),
    meta: { requiresAuth: true }
  },
  {
    path: '/admin',
    name: 'Admin',
    component: () => import('@/views/Admin.vue'),
    meta: { requiresAuth: true, requiresAdmin: true }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

// 路由守卫
router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore()
  
  // 检查认证状态
  if (!authStore.isAuthenticated) {
    try {
      await authStore.checkAuth()
    } catch (error) {
      // 认证失败，继续执行后续逻辑
    }
  }
  
  // 需要认证的页面
  if (to.meta.requiresAuth && !authStore.isAuthenticated) {
    next('/login')
    return
  }
  
  // 需要管理员权限的页面
  if (to.meta.requiresAdmin && !authStore.isAdmin) {
    next('/dashboard')
    return
  }
  
  // 已登录用户访问登录页，重定向到首页
  if (to.meta.requiresGuest && authStore.isAuthenticated) {
    next('/dashboard')
    return
  }
  
  next()
})

export default router
```

## 6. 应用初始化

```javascript
// main.js
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import router from './router'
import { useAuthStore } from '@/stores/auth'

const app = createApp(App)
const pinia = createPinia()

app.use(pinia)
app.use(router)

// 应用启动时检查认证状态
const authStore = useAuthStore()
authStore.checkAuth().finally(() => {
  app.mount('#app')
})
```

## 7. 错误处理

### 全局错误处理
```javascript
// utils/errorHandler.js
export const handleApiError = (error) => {
  if (error.response) {
    // 服务器响应错误
    const { status, data } = error.response
    
    switch (status) {
      case 401:
        return '未授权，请重新登录'
      case 403:
        return '权限不足'
      case 404:
        return '请求的资源不存在'
      case 500:
        return '服务器内部错误'
      default:
        return data.message || '请求失败'
    }
  } else if (error.request) {
    // 网络错误
    return '网络连接失败，请检查网络'
  } else {
    // 其他错误
    return error.message || '未知错误'
  }
}
```

## 8. 使用示例

### 在组件中使用
```javascript
// 在任何组件中
import { useAuthStore } from '@/stores/auth'

export default {
  setup() {
    const authStore = useAuthStore()
    
    // 检查是否已登录
    if (authStore.isAuthenticated) {
      console.log('用户已登录:', authStore.user.username)
    }
    
    // 检查是否是管理员
    if (authStore.isAdmin) {
      console.log('当前用户是管理员')
    }
    
    return {
      user: authStore.user,
      isAuthenticated: authStore.isAuthenticated,
      logout: authStore.logout
    }
  }
}
```

## 注意事项

1. **Cookie配置**: 确保 `withCredentials: true`，这样才能自动携带Session Cookie
2. **CORS配置**: 后端已配置CORS，前端可以正常跨域访问
3. **错误处理**: 统一在axios拦截器中处理401错误，自动跳转登录页
4. **状态持久化**: Session会在浏览器关闭后失效，刷新页面需要重新检查认证状态
5. **安全性**: 不要在前端存储敏感信息，依赖后端Session管理认证状态

## CSRF问题解决方案

如果遇到 `CSRF Failed: Origin checking failed` 错误，请按以下步骤解决：

### 1. 确认后端配置
确保Django的 `settings.py` 中包含你的前端地址：

```python
# CSRF 配置
CSRF_TRUSTED_ORIGINS = [
    "http://localhost:5175",  # 你的前端地址
    "http://127.0.0.1:5175",
    # 其他地址...
]

# CORS 配置
CORS_ALLOWED_ORIGINS = [
    "http://localhost:5175",  # 你的前端地址
    "http://127.0.0.1:5175",
    # 其他地址...
]
```

### 2. 前端CSRF Token处理
确保按照上面的配置正确处理CSRF Token：

1. **获取CSRF Token**: 在登录前先调用GET请求获取Token
2. **自动添加Token**: 在请求拦截器中自动为POST请求添加Token
3. **Cookie支持**: 确保 `withCredentials: true`

### 3. 调试CSRF问题
```javascript
// 调试CSRF Token
console.log('CSRF Token:', getCSRFToken())

// 检查Cookie
console.log('All Cookies:', document.cookie)

// 检查请求头
api.interceptors.request.use(config => {
  console.log('Request Headers:', config.headers)
  return config
})
```

### 4. 常见错误排查
- **端口不匹配**: 确保CSRF_TRUSTED_ORIGINS中的端口与前端实际端口一致
- **协议不匹配**: 确保http/https协议一致
- **Cookie未设置**: 确保首次GET请求成功获取了CSRF Token
- **Token过期**: CSRF Token有时效性，需要定期刷新

## 测试建议

1. 测试登录成功和失败的情况
2. 测试登录后刷新页面的状态保持
3. 测试登出后的状态清理
4. 测试路由守卫的权限控制
5. 测试网络错误的处理
6. **测试CSRF Token获取和使用**